<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Pierre Colson" />
  <title>Network Security fiche</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Network Security fiche</h1>
<p class="author">Pierre Colson</p>
<p class="date">January 2023</p>
</header>
<hr />
<p><strong>Markdown</strong> version on <a href="https://github.com/caillouc/Fiche_EPFL/blob/main/Network_Security/Network_Security.md?plain=1"><em>github</em></a><br />
Compiled using <a href="https://pandoc.org/"><em>pandoc</em></a> and <a href="https://github.com/caillouc/dotfile/blob/linux/gpdf.sh"><em><code>gpdf</code> script</em></a></p>
<h1 id="tls">TLS</h1>
<h2 id="general">General</h2>
<ul>
<li><strong>TLS</strong>: <strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity</li>
<li>It’s goal is to provide a <strong>secure channel between two peers</strong></li>
<li><strong>Entity authentication</strong>
<ul>
<li><strong>Server</strong> side of the channel is <em>always authenticated</em></li>
<li><strong>Client</strong> side is <em>optionally authenticated</em></li>
<li>Via <strong>Assymetric crypto</strong> or a symmetric <em>pre-shared key</em></li>
</ul></li>
<li><strong>Confidentiality</strong>
<ul>
<li><em>Data</em> send over the channel is <em>only visible to the endpoints</em></li>
<li>TLS does <em>not hide the length</em> of the data it transmits (but allows padding)</li>
</ul></li>
<li><strong>Integrity</strong>
<ul>
<li><em>Data</em> sent over the channel <em>cannot be modified</em> without detection</li>
<li>Integrity guarantees also cover reordering, insertion, deletion of data</li>
</ul></li>
<li><strong>Efficiency</strong>
<ul>
<li>Attempt to minimise crypto overhead</li>
<li>Minimal use of public key techniques; maximal use of symmetric key techniques</li>
<li>Minimise number of communication round trips before secure channel can be used</li>
</ul></li>
<li><strong>Flexibility</strong>
<ul>
<li>Protocol supports flexible choices of algorithms and authentication</li>
</ul></li>
<li><strong>Self negociation</strong>
<ul>
<li>The choice is done in hand, i.e. as part of the protocol itself<br />
</li>
<li>The is done through the version negociation and cipher suite negociation process: the client offers, server selects</li>
</ul></li>
<li><strong>Protection of negocation</strong>
<ul>
<li>Aim to prevent MITM attacker from performing version and cipher suite downgrade attacks</li>
<li>So the cryptography used in the protocol should also protect the hsoice of cryptography made</li>
</ul></li>
<li><strong>TLS</strong> aims for security in the face of <em>attacker who has complete control of the network</em></li>
<li>Only requirement from underlying transport: reliable, in order data-stream</li>
<li><strong>Handshake protocol</strong>: Authentication, negociation and key agreement</li>
<li><strong>Record protocol</strong>: Use those keys to provide confidentiality and integrity</li>
<li><strong>TLS 1.3</strong> design process goals
<ul>
<li><em>Clean up</em>: get rid ot flawed and unused crypto &amp; features</li>
<li><em>Improve latency</em> : for main handshake and repeated connections (while maintaining security)</li>
<li><em>Improve privacy</em>: hide as much of the handshake as possible</li>
<li><em>Continuity</em>: maintain interoperability with previous versions and support exisiting important use cases</li>
<li><em>Security Assurance (added later)</em>: have supporting analyses for changes</li>
</ul></li>
<li>TLS uses mostrly ‘boring’ cryptography yet is a very complex protocol suite</li>
<li>Some protocol design errors were made, but not too many</li>
<li>Legacy support for EXPORT cipher suites and liong tial of old versions opened up seious vulnerabilities</li>
<li>Lack of formal state-machine description, lack of API specification, and sheer complexity of specifications have let to many serious implementations errors</li>
<li>Poor algorithm choices in the Record Protocol should have been retired more aggressively</li>
<li>Most of this had been fixed in TLS 1.3</li>
<li>TLS 1.3 was developed hand-in-hand with formal security analysis</li>
<li>The design changed many times, often changes driven by security concerns identified through the analysis</li>
<li>Cryptography has evolved significantly in TLS</li>
<li>The largest shift was from RSA key transport to elliptic curve Diffie-Hellman, and from CBC/RC4 to AES-GCM</li>
<li>A second shift now underway is to move to using newer elliptic curves, allowing greater and better implementation security</li>
<li>A third shift is the move away from SHA1 in certs</li>
<li>A future shift is being considered to incorporate post-quantum algorithm</li>
<li>But Implementation vulnerabilities are bound to continue to be discovered</li>
</ul>
<h2 id="record-protocol">Record Protocol</h2>
<ul>
<li>The TLS Record Protocol provides a <strong>stream oriented</strong> API for applications making use of it
<ul>
<li>Hence TLS may fragment into smaller units or coalesce into larger units any data supplied by the calling application</li>
<li>Protocol data units in TLS are called <strong>records</strong></li>
<li>So each record is a fragment from a <strong>data stream</strong></li>
</ul></li>
<li>Cryptographic protectionin the TLS Record Protocol
<ul>
<li>Data origin authentication &amp; integrity for records using a MAC</li>
<li>Confidentiality for records using a symmetric encryption algorithm</li>
<li>Prevention of replay, reordering, deletion of records using per record sequence number protected by the MAC</li>
<li>Encryption and MAC provided simultaneously by use of AEAD in TLS 1.3</li>
<li>Prevention of reflection attack by key separation</li>
</ul></li>
<li><em>Datastream</em> is divided in different <strong>payload</strong></li>
<li>Each <em>payload</em> in concanated with a bit (<strong>ctype</strong>) and an optional <strong>padding</strong>; this give a <strong>fragment</strong></li>
<li>This is then given to <strong>AEAD</strong> encryption
<ul>
<li>Needs in input a <em>nonce</em>, some <em>associated data</em> (AD) (otype, v1.2, and len field) and a plaintext</li>
</ul></li>
<li><strong>ctype field</strong>
<ul>
<li>Single byte representing content type - indicates wheter contetn is handshake message, alert message or application data</li>
<li>AEAD-encryption inside record; header contains dummy value otype to limit traffic analysis</li>
</ul></li>
<li><strong>padding</strong>
<ul>
<li>Optional features that can be used ot hide true length of fragments</li>
<li>Not needed for encryption</li>
<li>Sequence of 0x00 bytes afer non-0x00 content type field</li>
<li>Removed after integrity check, so no padding oracle issues arise (Time side channel attack to recover lenght on plaintext)</li>
</ul></li>
<li><strong>AEAD nonce</strong>
<ul>
<li><span class="math inline"><em>N</em><em>o</em><em>n</em><em>c</em><em>e</em> = <em>S</em><em>Q</em><em>N</em>⨁<em>I</em><em>V</em></span></li>
<li>Constructed from 64 bits sequence number (<span class="math inline"><em>S</em><em>Q</em><em>N</em></span>)</li>
<li><span class="math inline"><em>S</em><em>Q</em><em>N</em></span> is incremented for each record sent on a connection</li>
<li><span class="math inline"><em>S</em><em>Q</em><em>N</em></span> is masked by XOR with <span class="math inline"><em>I</em><em>V</em></span> field</li>
<li><span class="math inline"><em>I</em><em>V</em></span> is a fixed (per TLS connection) pseudorandom value deirved from secrets in TLS handshake protocol</li>
<li><span class="math inline"><em>I</em><em>V</em></span> masking ensures nonce sequence is ‘unique’ per connection, good for security in multi-connection setting</li>
</ul></li>
<li><strong>Record header</strong>
<ul>
<li>Contains dummy field, legacy version field, length of AEAD ciphertext</li>
<li>Version field is always securely negociated during handshake</li>
<li><span class="math inline"><em>S</em><em>Q</em><em>N</em></span> is not included in header, but is maintained as a counter at each end of the connection (send and receive)</li>
</ul></li>
</ul>
<p><img src="./tls1.3_record_protocol.png" /></p>
<h2 id="handshake-protocol">Handshake Protocol</h2>
<ul>
<li>TLS 1.3: <strong>full handshake in 1 RTT</strong>
<ul>
<li>Achieved via feature reduction: we always do (EC)DHE in one of a shortlist of groups</li>
<li>Client includes DH shares in its first message, along with <code>Clienthello</code>, anticipating groups that server will accept</li>
<li>Server respons with single DH share in its <code>ServerKeyShare</code> response</li>
<li>If this works, a forward-secure key is established after 1 round trip</li>
<li>If server dos not like DH groups offered by client, it sends a <code>HelloRetryRequest</code> and a group description back to client
<ul>
<li>In this case, the handshake will be 2 round trips</li>
</ul></li>
</ul></li>
<li><strong>0-RTT handshake</strong> when resuming a previously established connection
<ul>
<li>Client + server keep shared state enabling them to derive a PSK (pre-shared key)</li>
<li>Client derives an ‘early data’ emcryption key from the PSK and can use it to include encrypted application data along with its first handshake message</li>
<li><em>sacrifices</em> certain securitty properties</li>
</ul></li>
<li>Because of reliance oc Ephemeral DS key exchange, TLS 1.3 handshake is <strong>forward secure</strong></li>
<li>This means: compromise of all session keys, DH values and signing keys has no impact on the security of earlier sessions</li>
<li>Use of ephemeral DH also means: if a server’s long term (signing) key is compromised, then an attacker cannot passively decrypt future sessions</li>
<li>Compare to RSA key transport option in TLS 1.2 and earlier: past and future passive interception using compromised server RSA private key</li>
</ul>
<h1 id="public-key-infrastructure-pki">Public Key Infrastructure (PKI)</h1>
<ul>
<li>In symmetric cryptography, main challenge is key distribution as keys need to be distributed via <strong>confidential and authentic</strong> channels</li>
<li>In public-key system, main challenge is key authentication (i.e., which key belongs to who) as keys need to be distributed via <strong>authentic channel</strong></li>
<li><strong>Public-key infrastructure (PKIs)</strong> provide a way to validate public keys</li>
<li><strong>CA</strong>: certificate Authority</li>
<li>A <strong>public-key certificate</strong> (or simply <strong>certificate</strong>) is signed and dinds a name to a public key</li>
<li><strong>Trust anchor, trust root</strong>: self-signed certificates of public keys that are allowed to sign other certificate</li>
<li><strong>X.509</strong> strandard format of digital certificate</li>
<li><strong>Root of trust</strong> is used to establish trust in other entities</li>
<li><em>Cryptography operations enable transfer of trust from one entity to another</em></li>
<li>Trust roots do not scale to the world
<ul>
<li><em>Monopoly model</em>: single root of trust
<ul>
<li>Problem: world cannot agree on who controls root of trust</li>
</ul></li>
<li>Obligarchy model: numerous roots of trust
<ul>
<li>Problems: Weakest link security: single compromised enables man-in-the-niddle attack; not trusting some trust roots results in unverifiable entities</li>
</ul></li>
</ul></li>
<li><strong>Let’s Encrypt</strong>
<ul>
<li>Goal: provide free certificate based on automated domain validation, issurance, and renewal</li>
<li>Based on ACME; Automated Certificate Management Environment</li>
</ul></li>
<li><strong>Certificate Revocation</strong>
<ul>
<li>Certificate revocation is a mechanism to invalidate certificates
<ul>
<li>After a private key is disclosed</li>
<li>Trusted employee / administrator leaves corporation</li>
<li>Certificate expiration time is usually chosen too long</li>
</ul></li>
<li>CA periodically publishes Certificate Revocation List (CRL)
<ul>
<li>Delta CRLs only contains changes</li>
<li>What to do if we miss CRL update?</li>
</ul></li>
<li>What is general problem with revocation
<ul>
<li>CAP theorem (Consistency, Availability, tolerance to partition): impossible to achieve all 3, must select one to sacrifice</li>
</ul></li>
</ul></li>
<li><strong>DANE</strong>
<ul>
<li>DNS-Based Authentication of Named Entities</li>
<li>Goal: Authenticate TLS servers without a certificate authority</li>
<li>Idea: use DNSSEC to bind certificate to names</li>
</ul></li>
<li><strong>Certificate Transparency</strong>
<ul>
<li>Will make all public end-entity TLS certificate public knowledge, and will hold CAs publicaly accountable for all certificates they issue</li>
<li>And it will do so withou introducing another trusted third party</li>
<li>A CT log is an append-only list of certificate</li>
<li>The log server verifies the certificate chain</li>
<li>Periodically append all new certificates to the append-only log and sign that list</li>
<li>Publish all updates of the signed list of certificates to the world</li>
<li>A CT log is not a “Super CA”
<ul>
<li>The log does not testify the goodness of certificates; it merely notes their presence</li>
<li>The log is public: everyone can inspect all the certificates</li>
<li>The log is untrusted: since the log is signed, the face that everyone sees the same list of certificate is cryptographically verifiable</li>
</ul></li>
<li>How CT improves security
<ul>
<li>Browser would require SCT for opening connection</li>
<li>Browser contacts log server to ensure that certificate is listed in the log</li>
</ul></li>
<li>Consequence
<ul>
<li>Attack certificate would have to be listed in public log</li>
<li>Attacks become publicly known</li>
</ul></li>
<li>Advantages
<ul>
<li>CT is fully operational today</li>
<li>No change to domain’s web server required</li>
</ul></li>
<li>Disadvantages
<ul>
<li>MitM attacks can still proceed</li>
<li>Browser still needs to contact Log eventually to verify that certificate is listed in log</li>
<li>Current CT does not support revocation</li>
<li>Malicious Log server can add bogous certificate</li>
<li>Management of list of trusted log server can introduce a kill switch</li>
</ul></li>
</ul></li>
<li><strong>Summary</strong>
<ul>
<li>Cannot tolerate additional latency of contacting additional server during SSL/TLS handshake</li>
<li>A key has to be immediately usable and verifiable after initial registration</li>
<li>Users shouldn’t be bothered in the decision process if certificate is legitimate</li>
<li>Need to cover entire certificate life cycle, including revocation, handing stolen and lost certificate</li>
<li>Secure crypto and secure protocols are insufficient
<ul>
<li>Numerous failure possibilities</li>
<li>User interface security and certificate management are critically important</li>
</ul></li>
<li>The entity who controls the root keys, controls all authentication and verification operations</li>
<li>PKI and revocation can result in a powerful ‘kill switch’, which can enable shouting down part of internet
<ul>
<li>Sovereign PKI continues to be an important research challenge</li>
</ul></li>
</ul></li>
</ul>
<h1 id="virtual-private-networks-vpns">Virtual Private Networks (VPNs)</h1>
<ul>
<li>VPN creates a <strong>Secure channel</strong> between two networks over an <strong>untrusted network</strong>
<ul>
<li><strong>Set-up phase</strong>: the gateways (tunnel endpoints) <em>authenticate</em> each other and <em>set up keys</em></li>
<li><strong>Tuneling phase</strong>:
<ul>
<li>Packets are encapsulated at the first gateway</li>
<li>… and decapsulated at the second</li>
</ul></li>
</ul></li>
<li>Simalar security properties as the TLS record protocol
<ul>
<li>Authentication of the source (handshake) data integrity (MACs)</li>
<li>Secrecy (symmetric encryption)</li>
<li>Replay suppression (sequence numbers)</li>
</ul></li>
<li>VPN setup 1: secure connection between two physically separared networks (site to site)
<ul>
<li>Replace private physical networks and leased lines
<ul>
<li>Even for leased lines, encryption may be desirable</li>
</ul></li>
</ul></li>
<li>VPN setup 2: secure connection of a remote host to company/university network (host to site)
<ul>
<li>Remote host can access resources in private network
<ul>
<li>Private IP addresses can be accessed without port forwarding</li>
<li>Services do not need to be exposed to the Internet</li>
</ul></li>
<li>First gateway located at the host
<ul>
<li>All traffic between host and private network is secure</li>
</ul></li>
</ul></li>
<li>VPN setup 3: VPN as a ‘secure’ proxy (to get a different IP address)
<ul>
<li>Circumvent censorship</li>
<li>Avoid trackigng by your ISP or in a public Wi-Fi network</li>
<li>Hide your IP address from websites</li>
<li>Spoof your location</li>
<li>Access restricted content</li>
<li>Downloads torrents (only legal ones of course)</li>
</ul></li>
<li>Inportant: VPN provider has access to metadata of all traffic</li>
<li><span class="math inline"><em>P</em><em>V</em><em>N</em>/<em>n</em><em>e</em><em>q</em><em>a</em><em>n</em><em>o</em><em>n</em><em>i</em><em>m</em><em>i</em><em>t</em><em>y</em></span></li>
<li>VPNs provide some limited anonimity properties
<ul>
<li>Local network and ISP only see that you send traffic through some VPN
<ul>
<li>They do not see which websites you access</li>
</ul></li>
<li>Web servers do not see you real IP address
<ul>
<li>Of course, if you use cookies or log in, anonimity is lost</li>
</ul></li>
</ul></li>
<li>VPN server can monitor and record all traffic</li>
<li>Why do we need VPNs when we have TLS?
<ul>
<li>VPNs protect <em>all</em> traffic: <em>blanket</em> security
<ul>
<li>DNS requests</li>
<li>Access to services that do not support TLs</li>
</ul></li>
<li>VPNs can give some access to services in private networks or behind firewalls</li>
</ul></li>
<li>Why do we need TLS when we have VPNs?
<ul>
<li>Data is only secure in the tunnel: no security outside of it</li>
<li>VPN server can see all uncrypted traffic <span class="math inline">→</span> TLS still necessary</li>
<li>With a VPN it is not possible to authenticate the webserver, only the tunnel endpoint</li>
</ul></li>
<li>VPNs can <em>negatively impact performance</em>
<ul>
<li>Additional cryptographic operations</li>
<li>Potential detours</li>
<li>Limited bandwidth at VPN server</li>
</ul></li>
<li>Generally, VPNSs do not provide higher availability
<ul>
<li>No build in defense against DoD or routing attack</li>
</ul></li>
<li>VPNs <em>can defend against targeted packet filtering</em>
<ul>
<li>Routers can recognize VPN packets but not content</li>
<li>Would need to drop all VPN packets</li>
</ul></li>
<li>VPNs themselves can become targets for DoS attacks</li>
<li>VPN vs <strong>VLAN</strong> (virtual local area network)
<ul>
<li>VPN (securely) <em>connect/combine</em> two different networks
<ul>
<li>One virtual network over multiple physical networks</li>
</ul></li>
<li>VLAN: set up multiple <em>isolated virtual networks</em> on a single physical infrastructure
<ul>
<li>Virtual networks are identified by tags, which are added to Ethernet frames</li>
<li>Often used in cloud-computing environments for isolating communication betweens VMs</li>
</ul></li>
</ul></li>
<li><strong>Authentication mechanism</strong>
<ul>
<li>Pre-shared key (PSK)</li>
<li>Public keys and certificates</li>
<li>Client: username/password</li>
</ul></li>
<li><strong>Tunneling mechanism</strong> (tunnel protocol)
<ul>
<li>Custom protocols (IPsec)</li>
<li>Tunnel over TLS (SSTP)</li>
</ul></li>
<li><strong>Layer of connected networks</strong> (inner protocol)
<ul>
<li>Layer 3 (Network Layer)</li>
<li>Layer 2 (Link Layer)</li>
</ul></li>
<li><strong>Implementation</strong>
<ul>
<li>User space</li>
<li>Kernel module</li>
<li>Hardware</li>
</ul></li>
<li>VPN creates <strong>virtual network adapter</strong></li>
<li>Can be used like any other network adapter</li>
<li>VPN interface can be used to all traffic or only selectively</li>
<li><strong>IPsec</strong> is a very large and complicated protocol
<ul>
<li>A typical IPsec session
<ul>
<li>Set up a security associaction (SA) via IKE</li>
<li>Encapsulate packets and tunnel them between SA endpoints</li>
</ul></li>
</ul></li>
<li><strong>Wireguard</strong>
<ul>
<li>No cryptographic agility
<ul>
<li>Only use state-of-the-art primitives</li>
<li>Simplify negociation and remove insecure promitives</li>
</ul></li>
<li>Very simple configuration - similar to <code>autorized_keys</code> file in ssh</li>
<li>Very small codebase, minimal attack surface, formally verifiable</li>
<li>handshake follows the Noise Protocol Framework
<ul>
<li>Built exclusively on (elliptic curve) Diffie-Hellman exchanges</li>
</ul></li>
<li>Each peer has a <em>static key</em> pair</li>
<li>Each peer creates <em>ephemeral key</em> pair</li>
<li>Derive symmetric keys from four Diffie helman combinations</li>
<li>1-RTT handshake</li>
<li>Wireguard does not store state before authentication and does not send responses to unauthenticated packets
<ul>
<li>Invisible to attackers</li>
<li>Prevent state-exhaustion attacks</li>
</ul></li>
<li>Initial message contains a timestamp to prevent replay attacks</li>
</ul></li>
<li>VPNs create <strong>secure channels</strong> on the network or link layer</li>
<li>VPNs and end-to-end security (TLS) <strong>complement each other</strong></li>
<li>Many different VPN protocols and applications
<ul>
<li><strong>IPsec has</strong> a long history and <em>numerous configuration options</em>
<ul>
<li>Very versatile but difficult to set up</li>
</ul></li>
<li><strong>WireGuard</strong> is a new VPN protocol with a focus on simplicity
<ul>
<li>Very few configuration parameters, no cryptographic agility</li>
<li>Simple to set up</li>
<li>Small codebase <span class="math inline">→</span> small attack surface</li>
</ul></li>
</ul></li>
</ul>
<h1 id="anonymous-communication-systems">Anonymous-Communication Systems</h1>
<ul>
<li>IP address leak metadata information
<ul>
<li>Who talks to whom, at what time, for how long, how frequently</li>
<li>NSA can log connection metadata, and later incriminate Snowden</li>
</ul></li>
<li><strong>Anonimity</strong> and related concepts is tricky
<ul>
<li>Anonimity is not a property of individual messages or flows; <em>You cannot be anonymous on your own</em></li>
</ul></li>
<li><strong>Sender anonimity</strong>
<ul>
<li>Adversary knows/is receiver</li>
<li>Adversary may learn message</li>
<li>Sender is unknown</li>
<li><strong>Sender anonimity set</strong>
<ul>
<li>Set of all senders/individuals indistinguishable from real sender</li>
<li>Can be used as a rough metric</li>
<li>Small set <span class="math inline">⟹</span> little anonimity</li>
</ul></li>
<li><strong>Return address</strong> Tolen provided by the sender</li>
</ul></li>
<li><strong>Receiver anonimity</strong>
<ul>
<li>Adversary knows/is sender</li>
<li>Adversary may choose message</li>
<li>Receiver is unknow</li>
<li>How does destination receive traffic
<ul>
<li><strong>Onion service</strong> (pseudonym known)</li>
</ul></li>
</ul></li>
<li><strong>Unlinkability</strong>
<ul>
<li>Adversary knows senders</li>
<li>Adversary knows receivers</li>
<li>Link between senders and receivers is unknown</li>
<li>Multiple users need to communicate at the same time</li>
</ul></li>
<li><strong>Unobservability</strong>
<ul>
<li>Adersary cannot tell whether any communication is taking place</li>
<li>Always send traffic</li>
</ul></li>
<li>Plausible deniability
<ul>
<li>Adersary cannot prove that any particular individual was responsible for a message</li>
</ul></li>
<li><strong>Threat models</strong>
<ul>
<li>There are various types of adversaries that can be considered</li>
<li>Degree of control: <em>local</em> or <em>global</em></li>
<li>Type of contorl: <em>network</em> or <em>compromised infrastructure</em></li>
<li>Tyoe of behavior: <em>passive</em> or <em>active</em></li>
</ul></li>
<li>User multiple proxies to avoit single point of failure (<em>cascade</em>)
<ul>
<li>Each proxy only sees addresses of two neighbors</li>
<li>Should work if the message addresse traverses at least one honest proxy</li>
</ul></li>
<li>Message and forwarding information is encrypted multiple times (onion)
<ul>
<li>All keys are necessary to decrypt</li>
</ul></li>
<li><strong>Mix-nets</strong>
<ul>
<li>Intented for sending anonymous emails
<ul>
<li>Latency is not a big concern</li>
<li>No connection setup, only individual messages</li>
</ul></li>
<li>Built on asymmetric cryptography</li>
<li>Each mix has a public/private key pair</li>
<li>Public keys and addresses are known to the sender</li>
<li>Problem: network attacker can observe in and outgoing messages
<ul>
<li>Each proxy should perform <strong>batching</strong>: Collect several messages before forwarding</li>
<li>Additionally, the proxies should change the order of (<strong>mixing</strong>) the messages, this is called <strong>threshold mix</strong></li>
<li>Important: messages need to be padded to a <em>fixed length</em> to make them indistinguishable</li>
</ul></li>
<li>To achive full Unobservability, user <strong>cover traffic</strong></li>
<li>How to send reply?
<ul>
<li>Idea: Inlcudes an <em>untraceable</em> path return address in its message</li>
</ul></li>
<li>Problems of mix-nets: high latency dut to batching and mixing; overhead due to asymmetric cryptography</li>
</ul></li>
<li><strong>Forward Security</strong>: if long term keys are compromised, anonimity of previously establisged circuits is preserved</li>
<li><strong>Circuit-based anonimity networks</strong> (onion routing)
<ul>
<li><em>Layered encryption</em>, no batching and mixing, no cover traffic</li>
<li>Flow-based: establish a <em>virtual circuit</em> (keys) once per flow, reuse it for all packets in the flow using only <em>symmetric key crypto</em></li>
<li>The <em>nodes</em> are called <strong>relays</strong></li>
<li>The virtual circuit is also called <strong>tunnel</strong></li>
<li><strong>Circuit setup</strong>
<ul>
<li>Initially, sendre knows long-term public keys or relays</li>
<li>The sender negociates shared keys with all relays on the path; this require (expensive) <em>asymmetric cryptography</em></li>
<li>The relays store the necessary state</li>
</ul></li>
<li><strong>Direct circuit setup</strong>: Establish state on relays by using a normal packet as for mixes
<ul>
<li>Message for each node contains address of next node and ephemeral Diffie-Helman share</li>
<li>Each node replies with its own ephemeral Diffie-Helman share</li>
<li>Ecnryption of setup packet uses long-term Diffie-Helman share</li>
<li>Relatively fast</li>
<li>Does not provide (immediate) forward security for long between communication patners</li>
</ul></li>
<li><strong>Telescopic circuit setup</strong>
<ul>
<li>Keys are negociated one relay at a time</li>
<li>The circuit is ‘extended’ by one hop at the tine</li>
<li>The setup is slower but it offers immediate forward security</li>
</ul></li>
<li><strong>Data forwarding</strong>
<ul>
<li>Packets for one or more flows are forwarded along the circuit</li>
<li>Only <em>symmetric cryptography</em> is used (AES)</li>
</ul></li>
<li><strong>Circuit tear-down</strong>
<ul>
<li>The circuit is destroyed to free state on relays or to prevent attacks</li>
<li>Can be both by sender and by intermediate ralays</li>
<li>Circuits have a limited lifetime, so they will eventually be destroyed</li>
</ul></li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th>.</th>
<th>Mix-net</th>
<th>Onion routing</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Forwarding system</td>
<td>Messag-based</td>
<td>Circuit based</td>
</tr>
<tr class="even">
<td>Layered encryption</td>
<td>yes (asymmetric)</td>
<td>yes (symmetric)</td>
</tr>
<tr class="odd">
<td>Mixing and batching</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="even">
<td>Cover traffic</td>
<td>yes (optional)</td>
<td>no</td>
</tr>
<tr class="odd">
<td>Forward Security</td>
<td>no</td>
<td>yes (Telescopic setup)</td>
</tr>
<tr class="even">
<td>Latency</td>
<td>high</td>
<td>low/medium</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Tor</strong>
<ul>
<li>Most widely used anonymous-communicatioin system</li>
<li>Circuits established over <em>3 relays</em></li>
<li><em>Telescopic setup</em></li>
<li><em>Per-hop TCP</em>, established on the fly
<ul>
<li>Avoid TCP stack fingerprints</li>
</ul></li>
<li><em>Per-hop TLS</em> (except on the last hop)
<ul>
<li>Multiple circuits over the same TLS connection</li>
<li>End to end HTPPS is possible</li>
</ul></li>
<li>Exit policies (exit can restrict the destinations they connect to)</li>
<li><strong>Onion services</strong>
<ul>
<li>Provide receiver anonimity</li>
<li>Use <code>.onion</code> URL (not in DNS)</li>
<li>How can we authenticate the onion service if that wants to be anonymous? The hash of Bob’s public key is the identifier of his hiddent service</li>
<li>Bod has conenctions to a set of special ralays called <em>introduction points</em> (IP)</li>
<li>To communicate, Alice connects to an IP and suggest a <em>rendez vous</em></li>
<li>Bob can connect to the <em>rendezvous</em> and start the communication</li>
</ul></li>
<li><strong>Tor cells</strong>
<ul>
<li>Basic unit is the cell (512 bytes)</li>
<li>It contains a circuit ID and ac ommand field (cleartext)</li>
<li>Same for cells in both directions</li>
</ul></li>
<li>A <em>relay</em> cell’s payload is decrypted and its digest is checked
<ul>
<li>If correct (this means the current relay is the intended recipient) check command</li>
<li>Otherwise (it is an intermediate node just forwarding the cell): replace circuit ID and forward cell along</li>
<li>Only exit relays sees unencrypted payload</li>
</ul></li>
<li><strong>Directry authorities</strong>
<ul>
<li>How do the clients know what relays there are?</li>
<li><em>10 directory authorities</em> running a consensus algorithm</li>
<li>The authorities track the state of relays, store their public keys</li>
<li>Client software comes with a list of the authorities’s key</li>
<li>The centralized authorities are an <em>important weakness</em> or Tor</li>
<li>Every relay periodically reports a signed statement</li>
<li>DAs also act as bandwidth authorities: verify bndwidth of nodes</li>
</ul></li>
<li>Censorship resistance in Tor
<ul>
<li>Relay nodes are publicaly listed and can be blocked</li>
<li>The Tor network contains several <em>bridge relays</em> (or <em>bridges</em>); not listed in main Tor directory, downloaded on demand; use to circumvent censors which block IP address of Tor delays</li>
</ul></li>
</ul></li>
</ul>
<h1 id="border-gateway-protocol-bgp-security">Border Gateway Protocol (BGP) Security</h1>
<ul>
<li><strong>Rerouting attacks</strong> issues
<ul>
<li>Not all traffic is encrypted/authenticated: DNS, HTTP</li>
<li>Even encryptted traffic leaks timing information</li>
<li>Rerouting can cause dropped packages and widespread outages</li>
<li>Hard to notice and impossible to solve without ISP cooperation</li>
<li>Undermine and invalidate other security protocols (can get a fake certificate using acme <span class="math inline">→</span> TLS becomes useless)</li>
</ul></li>
<li><strong>IP prefeix origination</strong> into BGP
<ul>
<li>Prefix advertised/announced by the AS who owns the prefix</li>
</ul></li>
<li><strong>IP prefix hijacking</strong>
<ul>
<li>A malicious (or misconfigured) AS announces a prefix it does not own</li>
<li>Today, no proper verification in place</li>
</ul></li>
<li><strong>BGP does not validate the origin of advertisements</strong></li>
<li><strong>BGP Interception</strong>
<ul>
<li>Selectively announcement of hijack prefix only to some neighbors
<ul>
<li>Problem: neighbors may still learn hijacked routes from their peers</li>
</ul></li>
<li>Use <strong>BGP poisonning</strong>
<ul>
<li>Only some of the neighbors use hijacked route</li>
</ul></li>
<li>Use BGP communities to ensure the announcement only reaches certain ASes
<ul>
<li>Can tell ans AS not to forward announcement to specific other ASes using the ‘NoExportSelected’ action</li>
</ul></li>
</ul>
<ol type="1">
<li>Set up an AS and border router or compromise someone else’s router</li>
<li>Configure router to originate the target (sub-)prefix</li>
<li>Get other ASes to accept the wrong route</li>
</ol></li>
<li><strong>BGP does not validate the content of advertisements</strong></li>
<li>ASes can modify the BGP path
<ul>
<li><em>Remove ASes from the AS path</em>; Motivation:
<ul>
<li>Attrack traffic by making path look shorter</li>
<li>Attrack sources that try to avoid a specific AS</li>
</ul></li>
<li><em>Add ASes to the AS path</em>; Motivation
<ul>
<li>Trigger loop detection in specific AS (DoS, BGP poisonning)</li>
<li>Make your AS look like it has richer connectivity</li>
</ul></li>
</ul></li>
<li><em>Security Goal</em>
<ul>
<li>Only an AS that owns an IP prefix is allowed to announce it
<ul>
<li>Can be proven cryptographically</li>
</ul></li>
<li>Routing message are authenticated by all ASes on the path
<ul>
<li>Cryptographic protection</li>
<li>ASes cannot add or remove other ASes in BGP announcements</li>
</ul></li>
</ul></li>
<li>Applying <strong>Best Current Practices</strong> (BCPs)
<ul>
<li>Securing the BGP peering session between routers (authentication, priority over other traffic)</li>
<li>Filtering routes by prefix and AS path</li>
<li>Filters to block unexpected control traffic</li>
</ul></li>
<li>Enter prefices into Internet Routing Registries and filter based on these entries</li>
<li><strong>Resource Public Key Infrastructure (RPKI)</strong>
<ul>
<li><em>Required</em>: ability to prove ownership of resources</li>
<li>RPKI cryptographically asserts the cryptographic keys of ASes and the AS numbers and IP prefixes they own</li>
<li>Root of trusts are ICANN and the five regional Internet registries</li>
<li>Enables the issuance of <em>Route Origination Authorizations</em> (ROAs)</li>
<li>ROA can states which AS is authorized to annouce certain IP prefixes
<ul>
<li>Can specify the maximum length of the prefix that the AS is allowed to advertise <span class="math inline">→</span> avoid sub-prefix hijacking</li>
<li>Certificates follow same delegation as IP addresses from RIRs</li>
</ul></li>
<li>ROAs are signed, distributed, and checked out-of-band</li>
<li><em>Distribution of ROAs</em>
<ul>
<li>ASes and/or RIRs create ROAs and upload them to repositories</li>
<li>Each AS periodically fetches repositories</li>
<li>All BGPs routers of an AS periodically fetch a list of ROAs from the local cache</li>
<li>When a BGP update message arrives, the router can check wheter a ROA exisits and it is consistent with the first AS entry of the BGP message</li>
</ul></li>
</ul></li>
<li><strong>BGPsec</strong>
<ul>
<li>Secure version of BGP</li>
<li>Secures the AS-PATH attribute on BGP announcements</li>
<li>Idea: Origin authentication + cryptographic signatures</li>
<li>Include Next AS in the signature so that both ASes confirm the link between them</li>
<li>Path prepending is no longer possible</li>
<li><em>Problems</em>
<ul>
<li>Routing policies can interact in ways that can cause BGP wedgies</li>
<li>Still vulnerable to protocol downgrade attacks</li>
<li>Performance degradation</li>
</ul></li>
<li>Unless security is the first priority or BGPsec deployment is very large, security benefits from partially deployed BGPsec are meager</li>
<li>Deployement is challenging</li>
</ul></li>
<li><strong>BGP</strong> was not designed with security in mind</li>
<li><strong>SCION</strong> Scalability, Control, and Isolation on Next Generation Networks (Replacement of BGP)</li>
<li><em>“BGP is one of the largest threats on the internet”</em></li>
<li>Proposals to improve BGP or competely replace it are emerging, but large-scale deployment is difficult</li>
</ul>
<h1 id="firewall-intrusion-detection-and-evasion">Firewall, Intrusion Detection and Evasion</h1>
<ul>
<li>A <strong>Firewall</strong> is a system used to protect or separate the <em>trusted network</em> from an <em>untrusted network</em>, while <em>allowing authorized communications</em> to pass from on side to the other</li>
<li><strong>Firewall</strong> enforce an access control policy between two networks</li>
<li><strong>Network firewall</strong> are a software appliance running on specitfic hardware or as virtual instance taht filter traffic between two or more network
<ul>
<li><em>Protect differect network segement</em></li>
</ul></li>
<li><strong>Host firewall</strong> provide a layer of software on one host that controls network traffic in and out of that single machine
<ul>
<li><em>Protect single host</em></li>
</ul></li>
<li><strong>Ingress</strong>:
<ul>
<li>Filter incoming traffic</li>
<li>From low security to high security net</li>
</ul></li>
<li><strong>Egress</strong>:
<ul>
<li>Filter outgoing traffic</li>
<li>From high security to low security net / outside</li>
<li>Gets often forgotten</li>
</ul></li>
<li><strong>Default policy</strong>:
<ul>
<li>Define what to do when no rule matches</li>
<li><em>Default accept</em> versus <em>default reject</em> policy</li>
</ul></li>
<li><strong>Deny Access</strong>:
<ul>
<li>Techniques to deny access
<ul>
<li><em>DROP</em>: Silently drop the packet</li>
<li><em>REJECT</em>: Drop packet and inform sender</li>
</ul></li>
</ul></li>
<li><strong>Stateless Firewall</strong>
<ul>
<li>Examine a packet at the network layer</li>
<li>Decision is based on packet header information</li>
<li><em>Pros</em>:
<ul>
<li>Application independant</li>
<li>Good performance and scalability</li>
</ul></li>
<li><em>Cons</em>:
<ul>
<li>No state or application context</li>
</ul></li>
</ul></li>
<li><strong>Statefull Firewall</strong>
<ul>
<li>Keep also track of the state of the network connections</li>
<li>Decision also based on session state</li>
<li><em>Pros</em>:
<ul>
<li>More powerful rules</li>
</ul></li>
<li><em>Cons</em>:
<ul>
<li>State for UDP?</li>
<li>Inconsistent state: Host vs Firewall</li>
<li>State explosion</li>
</ul></li>
</ul></li>
<li>Enforcing access control is not enough</li>
<li>Firewall can’t block all malicious traffic
<ul>
<li>Many ports must be kept open for legitimate applications to run</li>
<li>Users unwittingly download dangerous applications or other forms of malicious code</li>
<li>Peer-to-peer and instant messaging have introduced new injection vectors</li>
</ul></li>
<li>The lagacy firewall technology is effectively blinded by this evolution</li>
<li><strong>Next Generation of Firewall</strong> (NGFW)
<ul>
<li>Deep packet (content) inspection</li>
<li>Take aplication and protocol state into account</li>
<li><em>Pros</em>:
<ul>
<li>Even more powerful rules</li>
<li>Application &amp; protocol awarness</li>
</ul></li>
<li><em>Cons</em>:
<ul>
<li>Need to support many application protocols</li>
<li>Performance, scalability</li>
<li>Inconsistent state: host vs firewall</li>
</ul></li>
</ul></li>
<li><strong>Web Application Firewall</strong> (WAF)
<ul>
<li>Protect web-based applications from malicious requests</li>
<li><em>Request filtering</em>
<ul>
<li>Request patterns (signature)</li>
<li>SQL injection, cross-site scripting, buffer overflow atttempts, checking number of form parameters</li>
<li>Static or dynamic blacklisting/whitelisting</li>
</ul></li>
<li><em>Authentication</em>
<ul>
<li>User authentication</li>
<li>Session management</li>
</ul></li>
<li><em>TLS Endpoint</em>
<ul>
<li>WAFs are often implemented as a reverse proxy to protect public facing web applications</li>
<li>Reverse proxy: client is outside the internal network</li>
</ul></li>
</ul></li>
<li><strong>Deployemnt Challenges</strong>
<ul>
<li><strong>Scaling</strong>: protecting large number of hosts, endpoints, network segments is not trivial</li>
<li><strong>Complexity</strong>:
<ul>
<li>Firewall rulesets are complex and grow over time</li>
<li>Thousands of rule on a single firewall are no exception</li>
<li>Detection between channels of sync</li>
</ul></li>
<li><strong>Management</strong>:
<ul>
<li>Tools are needed to mange hundreds of firewalls and their rules securely</li>
<li>What is the process to change rulesets</li>
<li>Who has permission, monitoring of changes</li>
</ul></li>
<li><strong>Incentives</strong>:
<ul>
<li>Infrastructure Team: paid for providing connectivity blamed for disruptions</li>
<li>Security Team: paid to protect and disrupt connectivity</li>
</ul></li>
</ul></li>
<li><strong>Firewall attacks</strong>
<ul>
<li>Firewalls are just complex machine, with vulnerabilities and assumptions</li>
<li><strong>IP Source spoofing</strong>: Spoofing the IP address to bypass filters (Works for stateless protocols)</li>
<li><strong>Artificial Fragmentation</strong>:
<ul>
<li>Fragment packets to bypass rules</li>
<li>Without proper reassembly at the firewall the atteck gets through</li>
<li>Attack sent in multiple packets</li>
<li>Out of sequence packets</li>
<li>Fragmentation overlap</li>
</ul></li>
<li><strong>Vulnerabilities</strong>:
<ul>
<li>Exploiting vulnerabilities in firewall software/firmware/OS</li>
<li>Exploit vulnerabilities in target application</li>
</ul></li>
<li><strong>Denial of Service</strong>: Firewall state explosion
<ul>
<li>Data in ICMP ping packets, or use DNS requests as channel</li>
<li>Attack through VPN</li>
</ul></li>
</ul></li>
<li><strong>Payload encoding</strong>
<ul>
<li>Different encodings or mapping confuse detection</li>
<li>Different encoding and obfuscation schemas can be combined with noise insertion in millions ways</li>
<li>Encoding are not necessarily unique</li>
<li>Undefined or border cases are very effective for detection evasion</li>
<li>Different implementation of decoding on target application vs detection engine decoding</li>
</ul></li>
<li>Being a security product from a security vendor does not imply better code quality</li>
<li><strong>False Positive</strong>: I raised an alert but it was nothing</li>
<li><strong>Attack Detection</strong>
<ul>
<li>Basic detection approaches</li>
<li><strong>Reactive</strong>: System can only detect already known attacks</li>
<li><strong>Proactive</strong>: System can detect known and new, yes unknown attacks</li>
<li><strong>Deterministic</strong>:
<ul>
<li>System always performs the same given the same input</li>
<li>The same stimuli always result in same action</li>
<li>Reason for alert in known</li>
</ul></li>
<li><strong>Non-deterministic</strong>
<ul>
<li>System detection is fuzzy (heuristic, machine learning, sandboxing) and depends on current state of the world</li>
<li>Reason for alert typically not known</li>
</ul></li>
<li><strong>Static</strong>
<ul>
<li>Signature based detction</li>
<li>Static analysis and identification of known malware</li>
<li>Create and distribute signature of known malware</li>
<li><em>Pros</em>: Reliable, low rate of false positives</li>
<li><em>Cons</em>: Reactive, only known malware can be detected; Problem of large scale distribution of signatures</li>
</ul></li>
<li><strong>Behavior</strong>
<ul>
<li>Catatlogue and identify suspicious behavior</li>
<li>Run samples in sandbox/device</li>
<li>Classify upon observed behavior</li>
<li><em>Pros</em>: Proactive, detection on inknown malware</li>
<li><em>Cons</em>: Complex and computationally expensive; higher rate of false positives</li>
</ul></li>
<li><strong>Protocol analysis</strong>:
<ul>
<li>Analysis and decoding of protocols</li>
<li>Reassembly and normalization of traffic</li>
</ul></li>
<li><strong>Signatures</strong>: Compare attributes of observables
<ul>
<li>to a deny list or allow list</li>
<li>to patterns of known attacks/exploits/malware</li>
</ul></li>
<li><strong>Sandboxing</strong>:
<ul>
<li>Suspicious file is executed within a virtual environment</li>
<li>Specific actions are categorized and labeled as good or bad</li>
</ul></li>
<li><strong>Machine learning</strong>
<ul>
<li>Recognize complex patterns</li>
<li>Make decisions based on the data and assumptions formed from previous data</li>
</ul></li>
</ul></li>
<li><strong>Signature based detection</strong>
<ul>
<li>Deterministic and non-proactive</li>
<li>Signature-based concepts still lie at the heart of all modern detection systems … and will continue to be integral for the foreseeable future</li>
<li>Able to promptly identify and label a threat</li>
<li>Different signature systems used together to accurately label a known threat</li>
<li>Different signature systems used together to accurately label a known threat</li>
<li>For each new threat, a unique signature needs to be created</li>
<li>Frequent updates to signature database or online lookups</li>
<li>Progression and sophistication of signature-based detection systems depend upon human signature writers</li>
</ul></li>
<li><strong>Sandboxing Based Detection</strong>
<ul>
<li>Run malware in detonation chamber</li>
<li>Proactive and mostly deterministic</li>
<li>Sandoxing product typically run a samples in a (instrumented) sandbox environment</li>
<li>Examine/monitor runtime behavior of sample</li>
<li>Compare the behovior agains a list of rules previously developed by the vendor in their lab and applly machine learning for behavior classification</li>
<li><em>Pros</em>:
<ul>
<li>Proactive, can detect unknown threats;</li>
<li>No signature updates required</li>
</ul></li>
<li><em>Cons</em>:
<ul>
<li>Resource intensive</li>
<li>High latency</li>
<li>Difficult to scale</li>
</ul></li>
</ul></li>
<li><strong>Machine learning</strong>
<ul>
<li>Proactive and partially deterministic</li>
<li>Security vendors are now applying increasingly sophisticated machine learning elements into their cloud-based analysis and classification systems, and into theri products</li>
<li><em>Proven</em>: These techniques have already proven their value in Internet search, targeted advertsing, and social networking</li>
<li><em>No humans</em>: Machine learning largely removes humans and their biases to the developmen of an dimesional signature (or classification model)</li>
<li>Machine learning estimates probability distribution it approximates from training data</li>
<li><em>Golden rule</em>
<ul>
<li>Data you are going to work on needs to come from approximately the same distribution as the data you are training on</li>
</ul></li>
</ul></li>
<li><strong>Detection Evasion by Design</strong></li>
<li><strong>Malware Developtment Lifecycle</strong>
<ul>
<li>Develop new malware with desired functionality</li>
<li>Automatically create numerous permutated samples of the initial malware at massive scale</li>
<li>Protect samples from analysis</li>
<li>Make samples aware of sandboxing/detection technologies</li>
<li>Quality Assurance: Test sample against current anti-malware solutions before deployment</li>
<li>Malware used in a target attack will not be detected by anti-malware tools at the time of attack</li>
<li>Because it was tested for detection beforehand</li>
</ul></li>
<li><strong>Polymorphism Techniques</strong>
<ul>
<li>Tools manipulate the structure of the source code of the malware by reordering and replacing common programmatic routing</li>
<li>Swapping of equivalent code constructs</li>
<li>Changing the order of the code</li>
<li>Inserting noise</li>
<li>Compiler modulation</li>
</ul></li>
<li>Challenges and limitations of <strong>intrusion detection</strong>
<ul>
<li>Unable to inspect encrypted traffic</li>
<li>High number of false positive</li>
<li>Packet capturing and analysis at high link speed</li>
<li>Latency introduced by inspection engine</li>
<li>Application level attack</li>
<li>Policy/signature management</li>
</ul></li>
<li><strong>Accuracy</strong>: how close the measured values are to the target value</li>
<li><strong>Precision</strong>: Values of repeated measurements are clustered and have little scatter</li>
<li>“It is better to be roughly right than precisely wrong” <em>John Maynard Keynes</em></li>
<li><strong>True Positive</strong>: alert on true intrusion</li>
<li><strong>False Positive</strong>: alert but no intrusion</li>
<li><strong>False Negative</strong>: Intrusion but no aler</li>
<li><strong>True Negative</strong>: No alert on non-intrusion</li>
<li>Perfect detection
<ul>
<li>Difficulty: Built a detector with optimal balance between FPs and FN</li>
<li>Costs of detection errors
<ul>
<li>False Positive: Mobilize incident response team, stop service, interrupt business</li>
<li>False Negative: Getting compromised, forensics, downtime, cleanup</li>
</ul></li>
</ul></li>
<li>Detection Performance
<ul>
<li>A high number of false positives is a major challenge for detection system</li>
<li>Accurate detection is very challenging when rate of attacks is very low</li>
<li>Different detecton techniques achieve different sensitivity and specificity</li>
<li>Vendors claims to detect almost 100% of the sample are meaningless without indicating rate of false positives</li>
<li>Use a combination of diverse tests to increase precesion</li>
<li>Context is important</li>
</ul></li>
<li><strong>What to remember</strong>
<ul>
<li>100% protection is an illusion: assume you’re already compromised, and get compromised over again</li>
<li>A successful breach shoud be planned for, and handled in controlled process (rather than being treated as an execption)</li>
<li>Deploy tools and processes to quickly detect and remediate successful breaches</li>
<li>We need anti-virus, anti-malware, intrusion detection et al, butl we also need to know their limitations</li>
<li>Most devices can achieve a high detection rate
<ul>
<li>At the price of an unacceptably high rate of false positives</li>
</ul></li>
<li><em>An installed security patch/update is better than millions of detection signatures</em></li>
</ul></li>
</ul>
<h1 id="botnets-internet-of-things-iot">Botnets &amp; Internet of Things (IoT)</h1>
<ul>
<li>The word <strong>botnet</strong> is a combination of the words ‘robots’ and ‘network’. The term is usually used with a negative or malicious connotation
<ul>
<li><strong>Numerous devices</strong>: Build and manage a large network of compromised machines or devices</li>
<li><strong>Command and Control</strong> (CnC): Controlling a massive number of bots is a key requirement and challenge</li>
</ul></li>
<li><strong>Bot agents</strong>
<ul>
<li><em>Targets</em>
<ul>
<li>Criminals compromise an array of victim computers</li>
<li>A <em>boot agent</em> is installed on every victim/target</li>
</ul></li>
<li><strong>Challenge</strong>: how to communicate with the bot master
<ul>
<li>To receive commands and new payloads</li>
<li>To exfiltrate data</li>
</ul></li>
</ul></li>
<li><strong>Proxy layer</strong>
<ul>
<li>A distributed and redundent layer of <em>proxy agents</em></li>
<li><em>Proxy agent</em> are itself compromised machines</li>
<li><em>Bot agents</em> connects to proxies to:
<ul>
<li>Receive commands</li>
<li>Downloads payloads</li>
<li>Exfiltrate data</li>
</ul></li>
</ul></li>
<li><strong>Bot master</strong>
<ul>
<li>Control server
<ul>
<li>The <em>bot master</em> connects to <strong>crntrol server</strong>, which communicate with proxy agents</li>
<li><em>Asynchronous communication</em> between bot master and control server</li>
</ul></li>
<li><em>Drop Zone</em>: Host where exfiltrated data is stored until pickup by bot master</li>
</ul></li>
<li><strong>Botnet Command Models</strong>
<ul>
<li><em>No Control</em>
<ul>
<li>Default malicious behavior</li>
<li>Less flexible, detected by signatures</li>
<li>Most resistant to global shutdown</li>
</ul></li>
<li><em>Public infrastructure</em>
<ul>
<li>Use common application API’s</li>
<li>Generally reliable and ‘anonymous’</li>
<li>Mostly IRC, some P2P &amp; micro blogging</li>
<li>Majority of today’s botnets</li>
</ul></li>
<li><em>Resilient hybrids</em>
<ul>
<li>Default malicious behavior</li>
<li>Fallback plans id CnC unavailable</li>
<li>Pre-programmed contact points</li>
</ul></li>
<li><em>Private channels</em>
<ul>
<li>Custom and covert channels</li>
<li>Abuse &amp; alteration of common protocols</li>
<li>Short-term stealth</li>
<li>Signature detection easy once CnC observed</li>
</ul></li>
</ul></li>
<li>Locate the Command and Control Infrastructure
<ul>
<li>The ability of a bot agent to locate the CnC infrastructure is a critical requirement for maintaining control of the entire botnet</li>
<li>A <em>bot agent</em> that cannot connect to the control infrastructure cannot be controlled</li>
<li>The bot has to somehow identify the CnC infrastructure</li>
<li>The CnC communication can be intercepted by competitors and/or law enforcement to
<ul>
<li>Shutdown ot take over the botnet</li>
<li>Identify the bot master</li>
</ul></li>
</ul></li>
<li><strong>Fast Flux</strong>: A CnC resource with a given Fully Qualified Domain Name (FQDN) is mapped to a new set of IP addresses as often as every few minutes</li>
<li>Key methods for robust communication
<ul>
<li>Typical methods for a bot agent to locate and connect to a command and control instance or the bot net</li>
<li>Use <em>fixed ip</em>:
<ul>
<li>Easy to identify bot agent</li>
<li>Easy to identify controller</li>
<li>No flexibility</li>
<li>Easy to block botnet</li>
</ul></li>
<li>Use <em>fixed domain</em>:
<ul>
<li>Easy to identify bot agent</li>
<li>Harder to identify controller</li>
<li>Harder to shut down botnets</li>
<li>More flexibility</li>
</ul></li>
<li>Use <em>IP or domain flux</em>
<ul>
<li>Domain names and/or IP addresses change frequently</li>
<li>Very dynamic, moving target</li>
<li>Hard to shut down botnet</li>
</ul></li>
</ul></li>
<li><strong>Sinkholing</strong>: A botnet defense
<ul>
<li>A technique that is used to redirect the traffic from bots to an analysis server</li>
<li>A <strong>Sinkhole</strong> server gathers analytics and controls bots (if the authentication is also reverse engineered)</li>
<li>Reverse engineering of infected machines enables security researchers to replicate the DGA</li>
<li>This allow the identification and registration of some of the ‘rendez vous’ domains, and thereby redirect traffic of infected bots to the sinkhole server</li>
<li>Sinkhole server gather valuable telemetry and control bots (if the authentication is also reverse-engineered)</li>
</ul></li>
<li>Bot configuration files control key bot agent functionality on the target system
<ul>
<li><strong>Blacklists</strong>: An array of domains that the botnet permanently blocks on the target host
<ul>
<li>Prevent the victim from automatically, or manually, updating the machien or any anti-malware solutions</li>
<li>The victims machine can no longer get security protection</li>
</ul></li>
<li><strong>Web Injects</strong>: Specific HTML code injectd into victims browser session to exfiltrate sensitive data
<ul>
<li>When accessing a site of interest, the attackers html code is injected into the session</li>
<li>Exfiltration of user names &amp; passwords upon authentication, or hidden inserstion of fraudulent transactions</li>
</ul></li>
</ul></li>
<li><strong>Safety</strong> is the protectionm against random, unwanted incidents - resulting from coincidences or driven by the environment
<ul>
<li>The environment does not adapt to bypass safety measures</li>
</ul></li>
<li><strong>Security</strong> is the protection against intended incidents - resulting from a deliberate and planned act
<ul>
<li>Driven by targeted attacker</li>
<li>Deliberate acts driven by an adaptative attacker</li>
</ul></li>
<li><em>When is the last time you updated your connected fridge or your printer ?</em> <span class="math inline">→</span> problems</li>
<li>No perceptiohn of risk
<ul>
<li>People need highly visible incidents before they act</li>
<li>Insecure systems cannot be identified without extensive testing <span class="math inline">→</span> Illusion of control</li>
<li>We face considerabe difficulty to get resources (from C-level) to protect against abstract risks <span class="math inline">→</span> Accumulation of risks</li>
</ul></li>
<li><strong>Internet of Things</strong> (IoT)
<ul>
<li>System of interrelated and connected computing devices</li>
<li>Global network of ‘smart’ physical objects of various kinds for monitoring, data gathering, reporting, remote control etc…</li>
<li>Ability to transfer data without requiring interaction</li>
</ul></li>
<li><em>Industrial Internet of Things</em> (IIoT): Subset of IoT specific to industry</li>
<li><em>Critival Infrastructure</em> (CI): Processes, facilities, technologies, networks and systems that control and manage essential services</li>
<li><strong>Operational Technology</strong> (OT) and <strong>Information Technology</strong> (IT) systems have different operational requirements which impact their ability to respond and adapt to these threats
<ul>
<li><strong>Operational Technology</strong>
<ul>
<li>High availability &amp; integrity are vital with less stringent confidentiality requirements</li>
</ul></li>
<li><strong>Information Technology</strong>
<ul>
<li>Confidentiality &amp; Integrity are vital while availability is important</li>
</ul></li>
</ul></li>
<li>Security issues in IoT because their are such small devices that it is not always possible to fulfill the security requirement (e.g. not enough computatiom power for cryptography or random number generators)</li>
<li><strong>IoT attack surface</strong>
<ul>
<li>IoT connects innumerable everyday devices and Systems</li>
<li><em>Device</em>
<ul>
<li>Insecure software &amp; defaults</li>
<li>Lacking update mechanism</li>
<li>Vulnerabilities</li>
</ul></li>
<li><em>Communication</em>
<ul>
<li>Insecure communication</li>
<li>Weak or no cryptography</li>
<li>Lack of authentication</li>
</ul></li>
<li><em>Backend service</em>
<ul>
<li>Central control</li>
<li>Erosion of privacy</li>
<li>Data breaches</li>
</ul></li>
<li>Attacker perspective: IoT are easy target, way more than computer</li>
<li><em>Personal Computer</em>
<ul>
<li>Networked and <em>continuously hardened</em> in battle</li>
<li>Designed to withstand <em>external threats</em></li>
<li><em>Secure defaults</em></li>
<li>Exploit mitigation</li>
<li><em>Frequent secutity updates</em></li>
</ul></li>
<li>IoT, IIoT &amp; ICS devices
<ul>
<li>Ran isolated for decades</li>
<li>Designed for <em>high availability</em> and <em>safety</em>, <em>not secutity</em></li>
<li><em>Insecure defaults</em></li>
<li>Old code, <em>no protection</em></li>
<li><em>No security updates</em></li>
</ul></li>
</ul></li>
<li>Cyber devices require continued ‘security maintenance’
<ul>
<li>IoT devices often does not have a convinient way to be updated</li>
</ul></li>
<li>Traditional products rarely change after delivery whereas digital products constantly require security updates</li>
<li>Lifespan of decades for embedded or IoT devices
<ul>
<li>Replacement of devices is very difficult or prohibitively expensive</li>
<li>Options before purchase
<ul>
<li><strong>Code Escrow</strong>: Agree to have a copy of source code deposited with trusted third party</li>
<li><strong>Open source</strong>: Mandate to open source code in case of manufacturer exiting market</li>
</ul></li>
</ul></li>
<li>Many digital devices have to be certified to be used
<ul>
<li>By applying a security patch the certification is lost, further use of the device is illegal</li>
<li>Current (re)certification cannot keep up with dynamic security requirements</li>
<li><em>Certification timeline is outpaced by cyber security, and industry wide challenge</em></li>
<li>You’re doomed if you patched - you’re doomed if you don’t</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Challenges</strong></th>
<th><strong>What is needed</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>The security of individual components <em>does not imply the security of the complete system</em></td>
<td><ul>
<li>Design systems with <em>redundancy and resiliency</em></li>
<li>Realistic testing for the <em>complete system (end-to-end)</em></li>
</ul></td>
</tr>
<tr class="even">
<td>The continued innovation of attacker, treats technologies, society, and use-cases creates <em>a danamic and adaptative threats</em> landscape</td>
<td><ul>
<li>Prepare <em>for continued adaptation</em> to new threats, no matter what the driver or domain behind the attacker or threat</li>
<li>Comprehensive and continued security monitoring</li>
</ul></td>
</tr>
<tr class="odd">
<td>Softrware drives everything, and there is no such thing as a secure software. Prepare for continued <em>discovery and publication of publication of vulnerabilities in sotware and hardware</em></td>
<td><ul>
<li>Active <em>management of vulnerabilities</em></li>
<li>Robust and <em>scalable process to deploy security updates</em> timely and effeciently on <em>any connected device</em></li>
</ul></td>
</tr>
<tr class="even">
<td>We depend on a <em>complex supply chain of hardware and software</em> components, which <em>can not be fully controleld</em>. Assume that some components are already compromised</td>
<td><ul>
<li>Systematic <em>security and integrity testing</em> of all crtitical components</li>
<li>Comprehensive security appendix in supplier contacts</li>
</ul></td>
</tr>
</tbody>
</table>
<h1 id="dns-security-and-privacy">DNS Security and Privacy</h1>
<ul>
<li><strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem (DNS)
<ul>
<li>A distributed global lookup mechanism for translating names into other objects</li>
<li>Most used and least understood protocol in the internet</li>
<li>DNS is a mission-critical component for any online business</li>
<li>Yet this component is often overlooked and forgotten, until something breaks</li>
<li>DNS is the phone book of the internet: it tells computers where to send adn retrieve information</li>
<li>DNS is a <em>globally distributed</em>, loosely coupled, scalable, reliable, and dynamic database</li>
<li>DNS data is <em>maintained locally</em> and <em>retrievable globally</em></li>
<li>No single computer has all DNS data</li>
<li><strong>Namespace</strong>: hierarchical namespace defines names and ownership</li>
<li><strong>Resolvers</strong>: Clients to query servers</li>
<li><strong>Protocol</strong>: simple protocol, TCP or UDP port 53, no built in encryption, integrity, authentication</li>
<li><strong>Server</strong>: Make namespace available and store data DNS security and privacy [SF]</li>
</ul></li>
<li><strong>Security</strong>
<ul>
<li>Client expects <code>txid</code> to match (else drops response)</li>
<li>Random <code>txid</code> introduces 16 bit of entropy</li>
<li>If source port is random, mac 16 bit of entropy</li>
<li><em>No confidentiality</em></li>
<li><em>No integrity verifivation</em></li>
<li><em>No authentication</em></li>
</ul></li>
<li>Why attack DSN? Control DNS resolution of all clients server name server/resolver</li>
<li>Why study DNS security?
<ul>
<li>Use DNS to explain attack classes irrespective of protocol</li>
<li>Understand security impact of specific features in protocol design or implementation</li>
</ul></li>
<li>What could possibly go wrong? Cache poisonning, replay &amp; amplification, session state, dependencies, org structure, … DNS security and privacy [SF] DNS security and privacy [SF]</li>
<li><strong>DNS Root Zone</strong>
<ul>
<li>DNS root name server are the key to the internet kingdom</li>
<li><strong>Root server</strong> only resolve the IP addresses for the top level name servers</li>
<li>Every name resolution on the Internet either start with a query to a root server of, uses information that was once obtained from a root server</li>
</ul></li>
<li>Key challenge for root Server System: <em>Denial of Services attacks</em></li>
<li><strong>Cache poisoning</strong>
<ul>
<li>Attacker inserts incorrect resolution information</li>
<li><em>Assumption</em>
<ul>
<li>The attacker is off path</li>
<li>If required, the attacker could make client to resolve a FQDN the attacker controls</li>
</ul></li>
<li><em>Prerequisite</em> to inject a fake response, the attacker needs to
<ul>
<li>Raply faster - before true response arrives</li>
<li>Guest relevant parameters of query to get attacker reply processed</li>
</ul></li>
<li>Response is only processed with matching TXID of the query</li>
<li>Attacker has to wait for TTL for next attempt</li>
<li>Response must match source IP/port of query</li>
<li>Attack method
<ul>
<li>Attacker controls authoritative names server and a domain <span class="math inline"><em>D</em></span></li>
<li>Attacker tricks user to resolve <span class="math inline"><em>D</em></span> (hacked site, mail, social media, etc…)</li>
</ul></li>
<li>Attacker Execution
<ul>
<li>Client resolves <span class="math inline"><em>D</em></span></li>
<li>Name server replies with an additional section in DNS response, adding unrelated information for <code>bank.com</code> for example</li>
<li>DNS do not cache information not related to the query anymore</li>
</ul></li>
<li>Lond TTL = high security, low TTL = low security</li>
<li><strong>Forced lookup</strong>: Attacker can force a server to look something up</li>
<li><strong>Multiples replies</strong>: Who said you can only reply once</li>
<li><strong>Multiples domains</strong>: Who said you can only resolve one domain name</li>
<li>Attack patern
<ul>
<li>Manipulate DNS configuration settings on internal nerwork or local host</li>
<li>Have target point to attackers name server</li>
</ul></li>
<li><em>WAN Network</em>
<ul>
<li>Scan ISP networks, identify vulnerable routers or weak/default passwords</li>
<li>Attack poorly protected client router of Internet Service Providers</li>
</ul></li>
<li><em>LAN network</em>
<ul>
<li>Attack client router or DHCP server direclty</li>
<li>Attack DHCP exchange in local network</li>
</ul></li>
<li><em>Local host</em>
<ul>
<li>Manipulate DNS local host settings on compromised machine</li>
</ul></li>
</ul></li>
<li>Protocol cannot be understood in isolation
<ul>
<li>If you are not aware of how all the protocols and your systems interact, you will miss vulnerabilities that are obvious to an attacker</li>
<li><strong>DNS</strong>
<ul>
<li>DNS protocol has only 65 536 possible transactions IDs (16 bits)</li>
<li>Relying on TTL for security</li>
</ul></li>
<li><strong>TCP/IP</strong>
<ul>
<li>IP protocol has only 65 536 possible source port (16 bits)</li>
<li>Implementation with no random source port</li>
</ul></li>
</ul></li>
<li>One standard to ensure integrity and authenticity: <strong>DNSSEC Extensions</strong>
<ul>
<li>DNSSEc is aset of security extensions for verifying the identity of DNS root and aithoritative nameservers</li>
<li>Designed to prevent DNS cache poisoning &amp; other attacks</li>
<li>It does not encrypt communications</li>
<li>DNS over TLS or HTTPS (DoT &amp; DoH) do encrypt DNS queries</li>
</ul></li>
</ul>
<h1 id="distributed-denial-of-service-ddos">(Distributed) Denial of Service (D)Dos</h1>
<h2 id="introduction-and-generic-attacks">Introduction and Generic Attacks</h2>
<ul>
<li><strong>Denial-of-servive</strong> (DoS) attacks try to <em>make a service or network resource unavailable</em> to its intended/legitimate users</li>
<li>Typically achieved by <em>exhausting available resources</em> by sending an excessive amount of traffic/packets/request</li>
<li><strong>Distributed DoS</strong> attacks use many different sources simultaneously, often by creating and using so-called <em>botnets</em></li>
</ul>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Network links</strong></th>
<th><strong>Network Devices</strong>/ <strong>Network stack</strong></th>
<th><strong>Applications</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>Description</em></td>
<td>Volumetric attack</td>
<td>Protocol attack</td>
<td>Application-layer attacks</td>
</tr>
<tr class="even">
<td><em>Unit of measurements</em></td>
<td>Bits per second (bps)</td>
<td>Packets per second (pps)</td>
<td>Request per second (rps)</td>
</tr>
<tr class="odd">
<td><em>Used mechanism/ examples</em></td>
<td><ul>
<li>Reflection and amplification</li>
</ul></td>
<td><ul>
<li>Reflection</li>
<li>Stae exhaustion</li>
</ul></td>
<td><ul>
<li>Computational</li>
</ul></td>
</tr>
</tbody>
</table>
</body>
</html>
