<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Pierre Colson" />
  <title>Advanced computer architecture fiche</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Advanced computer architecture fiche</h1>
<p class="author">Pierre Colson</p>
<p class="date">June 2022</p>
</header>
<hr />
<p><strong>Markdown</strong> version on <a href="https://github.com/caillouc/Fiche_EPFL/blob/main/Advanced_computer_architecture/Advanced_computer_architecture.md?plain=1"><em>github</em></a><br />
Compiled using <a href="https://pandoc.org/"><em>pandoc</em></a> and <a href="https://github.com/caillouc/dotfile/blob/linux/gpdf.sh"><em><code>gpdf</code> script</em></a></p>
<h1 id="general-purpose-architectures">General Purpose Architectures</h1>
<h2 id="exploiting-ilp-dynamically">Exploiting ILP Dynamically</h2>
<h3 id="pipelining">Pipelining</h3>
<ul>
<li><strong>ILP</strong> : Instruction Level Parallelism</li>
<li><strong>Pipelining</strong> is a simple form of ILP : Several instructions are being executed at once
<ul>
<li>The <em>latency</em> is unmodified</li>
<li>The <em>throughput</em> is higher</li>
<li>Adding resgisters to cut combinatorial logic</li>
<li>Each new register add a bit of latency and increase de power consumption</li>
<li><strong>Dependencies</strong> slow down the possibility of pipelining
<ul>
<li>To detect dependencies we can simply have a look to the destination registers of intermediaire registers and verify that they are not needed by the instructions that have been fetch</li>
<li>Either add logic to detect dependencies (hardware) and stall the pipeline or requires the right number of nop between instructions to avoid issues (compiler)</li>
</ul></li>
<li>Several instructions are run in parallel</li>
<li><strong>Control hazards</strong> limit the usability of the pipeline
<ul>
<li>Must squash fetched and decoded instruction following a branch</li>
</ul></li>
<li><strong>Data hazards</strong> limit the usability of the pipeline
<ul>
<li>Whenever the next instruction cannot be executed, the pipeline is stalled and no new useful work is done until the problem is solved</li>
<li>Can be solved by forwarding newer values (bypass the register file)</li>
</ul></li>
<li><strong>Rigid sequencing</strong>
<ul>
<li>Special “slots” for everything even if sometimes useless (e.g. MEM before WB)</li>
<li>Every instruction must be coerced to the same framework</li>
<li>Structural hazards avoided “by construction”</li>
</ul></li>
</ul></li>
<li><strong>Dynamic Scheduling</strong> : solve dependencies in hardware</li>
</ul>
<figure>
<img src="./pipeline_with_forwarding.png" alt="" /><figcaption>Simple Pipeline with Forwarding</figcaption>
</figure>
<h3 id="dynamic-scheduling">Dynamic Scheduling</h3>
<ul>
<li>While waiting for a dependency to be resolved, schedule other instruction
<ul>
<li>Instructions can be executed out of program order (but the result must still be correct)</li>
</ul></li>
<li>Dynamic scheduling allow <strong>Binary compatibility</strong>, the same code will work for different processors, Parallelism is handle in hardware on not by the compiler</li>
<li><strong>Structural hazars</strong>
<ul>
<li>Are the required resources available</li>
<li>Previously handled by rigid pipeline</li>
</ul></li>
<li><strong>Data hazards</strong>
<ul>
<li>RAW : Are the operands ready to start execution</li>
<li>WAR and WAW : The new data overwrite something which is still required</li>
</ul></li>
<li><strong>RAW</strong> : Read after write</li>
<li><strong>WAR</strong> : Write after read</li>
<li><strong>WAW</strong> : Write after write</li>
<li>Dynamic pipelines may create WAW hazards</li>
<li>Register after the decode state is bigger since it must be abble to store several instructions. A <strong>reservation station</strong> checks that the operands are available (RAW) and that the execution Unit is free (Structural Hazard), then starts execution
<ul>
<li>Unavailable operands are identified by the name of the reservation station in charge of thr originating instruction</li>
<li><em>Tag</em> keeps track of which instruction will generate the result I am waiting for. Tag here are the name of an entry of the reservation station
<ul>
<li><em>Tag</em> cannot be register name since they are not unique</li>
<li><em>Tag</em> cannot be the PC (even tough it looks) since we can have a branch in a loop for example</li>
</ul></li>
<li>Can find dependencies using the reoder buffer (see later)
<ul>
<li>Reorder buffer keeps track of all instructions that have not been commited yet</li>
<li>Reorder buffer can be used to bypass the register file</li>
</ul></li>
</ul></li>
<li><strong>Implicit register renaming</strong> removes WAR and WAW hazards</li>
<li>New results are seen at their inputs through special results bus(es)</li>
<li>Writeback into the registers can be done in order or out of order</li>
<li><strong>Architectural states</strong> are known by the programer</li>
<li><strong>Microarchitectural states</strong> are know not by the programer, only used by the processor</li>
<li>Exception handler should now exactly where a problem has occured, especially for <strong>non terminating exceptions</strong> (e.g., page fault) so that they handle the event and resume exactly where the exception occured
<ul>
<li><em>Precise exceptions</em> : Reordering at commit; user view is that of a fully in-order processor</li>
<li><em>Imprecise exceptions</em> : No reordering; out-of-order completion visible to the user</li>
</ul></li>
<li>A processor can do <em>whatever it wants</em> provided that it gives the <em>appearance of sequentail execution</em></li>
<li><strong>Reorder buffer</strong> (ROB) : redorders instructions in the commit unit
<ul>
<li>Pointer to the head and to the tail</li>
<li>Every time I decode an instruction, I add it to the Reorder buffer with the corresponding <em>tag</em> and the destination register</li>
<li>During execution <em>tag</em> are replaced by actual values/results; more precisly the only instruction with the given <em>tag</em> will be updated</li>
<li>When the head pointer is ready (results has been computed) we can commit; Otherwise we wait and do not commit any instructions</li>
<li>PC is also stored in the Reoder buffer to remember where was an eventual exception. This way wen can rejump to this instruction once the exception have been handled (or not, for terminating excepetion)</li>
<li>There is an address destination slot as well as a register destination slot. Either the register or the address slot is used, because the results has to be written either to memory or to a register</li>
</ul></li>
<li>Informations/results bypass the register file in order to be reuse faster, however in register file results are in order</li>
<li>When a synchronus exception happens, we do not report it but we <strong>mark the entry</strong> corresponding to the instruction which caused the exception in the ROB
<ul>
<li>When we would be ready to <strong>commit</strong> the instruction, we <strong>raise the exception</strong> instead</li>
<li>We also <strong>squash</strong> the content of the ROB and of all RSs</li>
</ul></li>
<li>The way to detect and resolve dependencies through memory is the same as for registers; For every load, check the ROB
<ul>
<li>If there is <strong>no store to the same address</strong> in the ROB, get the value from memory</li>
<li>If ther is a <strong>store to the same address</strong> in the ROB either get the value (if ready) or the tag</li>
<li>If there is a store to an <strong>unknown address</strong> in the ROB or if the address of the load in unknown, <strong>wait</strong></li>
</ul></li>
<li>Additional memory dependencies can be solved via a <strong>Load Queue</strong> and a <strong>Store Queue</strong> (mimic the ROB). They would replace the memory reservation station
<ul>
<li>Load queue entries have a pointer to an entry in the store queue to know every store that where before the load</li>
</ul></li>
<li>Last improvment is Superscalar, having several fetch and decode unit as well as several alu and memory unit</li>
</ul>
<figure>
<img src="./dynamically_schedule.png" alt="" /><figcaption>Dynamically Scheduled Processor</figcaption>
</figure>
<h3 id="renaming-registers">Renaming registers</h3>
<ul>
<li><strong>Register renaming</strong> is used to get rid of WAR and WAW</li>
<li><strong>Location for rename registers</strong>
<ul>
<li>Merged rename and architectural RF</li>
<li>Slpit rename and architectural RFs</li>
<li>Renamed values in the reorder buffer</li>
<li>Renamed values in the reservation stations (a.k.a. shelving buffers)</li>
</ul></li>
<li>Tracking the mapping table: Where is Physically an Architectural Register
<ul>
<li>Mapping in a <strong>Mapping table</strong></li>
<li>Renaming in the <strong>Rename buffer</strong></li>
</ul></li>
<li><strong>State Transition in a Merged file + Information flow</strong>
<ul>
<li>Initialization : First <span class="math inline"><em>N</em></span> registerss are ‘AR’, others are ‘Available’</li>
<li><em>Available</em> <span class="math inline">→</span> <em>Renamed Invalid</em> : Instruction enter the Reservations Stations and/or the ROB: register allocated for the result (i.e., register uninitialised)
<ul>
<li>Read new PhR from top of Free Register Table</li>
<li>Create new mapping <em>LogDest</em> <span class="math inline">→</span> <em>Dst</em> in the mapping table</li>
<li>Set corresponding <em>Busy-Bit</em> (=invalid) in the Status Table</li>
</ul></li>
<li><em>Renamed Invalid</em> <span class="math inline">→</span> <em>Renamed Valid</em> : Instruction completes (i.e., register initialised)
<ul>
<li>Write PhR <em>Dest</em> indicatied in the I-Queue</li>
<li>Reset corresponding <em>Busy-bit</em> (=valid) in the Status Table</li>
<li>Mark as <em>Done</em> in the corresponding entry in the ROB</li>
</ul></li>
<li><em>Renamed Valid</em> <span class="math inline">→</span> <em>Architectural Register</em> : Instruction commits (i.e., register “exists”)
<ul>
<li>Implicit (removal of historical mapping <em>LogDest</em> <span class="math inline">→</span> <em>Dest</em>)</li>
</ul></li>
<li><em>Architectural Register</em> <span class="math inline">→</span> <em>Available</em> : Another instruction commit to the same AR (i.e., register is dead)
<ul>
<li>Free PhR indicated by <em>OldDest</em> in the entry removed for the ROB</li>
</ul></li>
<li><em>Renamed Invalid</em> and <em>Renamed Valid</em> <span class="math inline">→</span> <em>Available</em> : Squashing
<ul>
<li>Restore mapping from all squashed ROB entries (from tail to head) as <em>LogDest</em> <span class="math inline">→</span> <em>Dest</em></li>
<li>Reset corresponding <em>Busy-Bit</em> (=valid) in the Status Table</li>
</ul></li>
</ul></li>
<li><strong>State Transition Replaced by Copying in Stand-aloone RFF</strong>
<ul>
<li>Initialization : All Rename registers are “Available”</li>
<li><em>Available</em> <span class="math inline">→</span> <em>Renamed Invalid</em> : Instruction enter the Reservation Stations and/or the ROB: register allocated for the results (i.e., register uninitialised)</li>
<li><em>Renamed Invalid</em> <span class="math inline">→</span> <em>Renamed Valid</em> : Instruction completes (i.e., register initialised)</li>
<li><em>Renamed Valid</em> <span class="math inline">→</span> <em>Available</em> : Instruction commits (i.e., register “exists”) <span class="math inline">⇒</span> Value is copied in the Architectural RF</li>
<li><em>Renamed Invalid</em> and <em>Renamed Valid</em> <span class="math inline">→</span> <em>Available</em> : Squashing (no copy to the Architectural RF)</li>
</ul></li>
</ul>
<figure>
<img src="./renaming_register.png" alt="" /><figcaption>Merged Register File</figcaption>
</figure>
<h3 id="predictions-and-speculation">Predictions and Speculation</h3>
</body>
</html>
